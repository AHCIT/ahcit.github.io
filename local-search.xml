<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL基础面试问题总结</title>
    <link href="/2023/01/14/MySQL%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/14/MySQL%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基础面试问题总结"><a href="#MySQL基础面试问题总结" class="headerlink" title="MySQL基础面试问题总结"></a>MySQL基础面试问题总结</h1><h2 id="MySQL存储引擎架构"><a href="#MySQL存储引擎架构" class="headerlink" title="MySQL存储引擎架构"></a>MySQL存储引擎架构</h2><ul><li><p>MySQL存储引擎采用的是插件式架构，支持多种存储引擎</p></li><li><p>可以为不同的表设置不同的引擎来适应不同的场景</p></li><li><p>存储引擎是基于表的而非数据库</p></li></ul><h2 id="MyISAM-和-InnoDB-的区别是什么"><a href="#MyISAM-和-InnoDB-的区别是什么" class="headerlink" title="MyISAM 和 InnoDB 的区别是什么"></a>MyISAM 和 InnoDB 的区别是什么</h2><h3 id="1-是否支持行级锁"><a href="#1-是否支持行级锁" class="headerlink" title="1)    是否支持行级锁"></a>1)    是否支持行级锁</h3><p>MyISAM只有表级锁(table-level locking)，而InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁。</p><h3 id="2-是否支持外键"><a href="#2-是否支持外键" class="headerlink" title="2)    是否支持外键"></a>2)    是否支持外键</h3><p>MyISAM不支持外键，InnoDB支持外键</p><h3 id="3-是否支持事务"><a href="#3-是否支持事务" class="headerlink" title="3)    是否支持事务"></a>3)    是否支持事务</h3><p>MyISAM不支持事务，InnoDB支持事务。隔离级别默认使用可重复读，可以避免幻读的情况发生。</p><h3 id="4-是否支持数据库异常崩溃后的安全恢复"><a href="#4-是否支持数据库异常崩溃后的安全恢复" class="headerlink" title="4)    是否支持数据库异常崩溃后的安全恢复"></a>4)    是否支持数据库异常崩溃后的安全恢复</h3><p>MyISAM不支持，InnoDB支持，数据库重启时依赖redo log。</p><h3 id="5-是否支持MVCC"><a href="#5-是否支持MVCC" class="headerlink" title="5)    是否支持MVCC"></a>5)    是否支持MVCC</h3><p>MVCC是指多版本并发控制。MVCC是在并发访问数据库时，通过对数据进行多版本控制，避免因写锁而导致读操作的堵塞，从而很好的优化并发堵塞问题。仅InnoDB支持。</p><h3 id="6-索引的实现不一样"><a href="#6-索引的实现不一样" class="headerlink" title="6)    索引的实现不一样"></a>6)    索引的实现不一样</h3><p>虽均使用B+Tree作为索引结构，但是两者的实现方式不太一样。</p><p>a)     InnoDB引擎中，其数据文件本身就是索引文件。</p><p>b)    MyISAM，索引文件和数据文件是分离的。</p><p>c)     InnoDB引擎中，表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><h2 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="MySQL 查询缓存"></a>MySQL 查询缓存</h2><p>查询时会先查询缓存，可以提升查询的响应速度，8.0版本移除了该功能。可以通过query_cache_type参数控制是否启用缓存。开启后使用相同的查询条件与数据会直接命中缓存。但是也存在3类无法命中缓存的情况：</p><p>a)     查询条件在字符上存在差异；</p><p>b)    查询中包含用户自定义的函数、存储函数、用户变量、临时表、系统表；</p><p>c)     缓存系统中涉及的表发生变动后，与该表相关的缓存会集体失效</p><p>缓存虽然可以提升查询速度，但是带了额外的开销，不适用于写密集的应用。即便是开启也需要将缓存空间的大小控制在几十MB的范围内。</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><p>广义上的事务是逻辑上的一组操作，要么都执行，要么都不执行。数据库事务指的是保证多个对数据库的操作在宏观上可以被当作一个整体执行，要么一起成功，要么一起失败。</p><p>事务具有四个性质：</p><p>a)     原子性：事务是最小执行单位，不允许分割。该性质保证动作要么全部完成，要么完全不起作用；</p><p>b)    一致性：执行事务前后，数据保持一致。例如转账场景下，转账人与被转账人的总额应该是不变的；</p><p>c)     隔离性：并发访问数据库时，一个用户的事务不会被其他事务所干扰，并发事务之间数据库时独立的；</p><p>d)    持久性：一旦事务被提交执行，那么其对数据库中的数据修改是持久性的，即使数据库发生故障了也不应该对其修改的数据产生任何影响。</p><p>需要说明的是以上提到的原子性、隔离性、持久性均是为了保证一致性。换句话说，原子性、隔离性、持久性是数据库的性质，而一致性则属于应用程序的性质。</p><h2 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="并发事务带来了哪些问题"></a>并发事务带来了哪些问题</h2><h3 id="1-脏读："><a href="#1-脏读：" class="headerlink" title="1)    脏读："></a>1)    脏读：</h3><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><h3 id="2-丢失修改："><a href="#2-丢失修改：" class="headerlink" title="2)    丢失修改："></a>2)    丢失修改：</h3><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><h3 id="3-不可重复读："><a href="#3-不可重复读：" class="headerlink" title="3)    不可重复读："></a>3)    不可重复读：</h3><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务修改了该数据，那么在第一个事务中会出现两次读取的数据不一致的情况，称之为不可重复读。</p><h3 id="4-幻读："><a href="#4-幻读：" class="headerlink" title="4)    幻读："></a>4)    幻读：</h3><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><h2 id="不可重复读和幻读有什么区别"><a href="#不可重复读和幻读有什么区别" class="headerlink" title="不可重复读和幻读有什么区别"></a>不可重复读和幻读有什么区别</h2><p>不可重复读的重点是内容修改或记录减少比如多次读取一条记录发现其中某些记录的值被修改；</p><p>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</p><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h2 id="SQL-标准定义了哪些事务隔离级别"><a href="#SQL-标准定义了哪些事务隔离级别" class="headerlink" title="SQL 标准定义了哪些事务隔离级别?"></a>SQL 标准定义了哪些事务隔离级别?</h2><p>SQL 标准定义了四个隔离级别：</p><p><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p><p><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="MySQL-的隔离级别是基于锁实现的吗"><a href="#MySQL-的隔离级别是基于锁实现的吗" class="headerlink" title="MySQL 的隔离级别是基于锁实现的吗"></a>MySQL 的隔离级别是基于锁实现的吗</h2><p>MySQL的隔离级别是基于锁和MVCC共同实现的。其中可串行化是通过锁实现的。剩下的读未提交、读已提交、可重复读均是基于MVCC实现。不过，可串行化之外的其他隔离级别可能也需要用到锁机制，就比如可重复读在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h2 id="MySQL-的默认隔离级别是什么？"><a href="#MySQL-的默认隔离级别是什么？" class="headerlink" title="MySQL 的默认隔离级别是什么？"></a>MySQL 的默认隔离级别是什么？</h2><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是可重复读。</p><h2 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="表级锁和行级锁了解吗？有什么区别？"></a>表级锁和行级锁了解吗？有什么区别？</h2><p>MyISAM仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性能非常差。</p><p>InnoDB不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（一行或者多行），所以其对并发写入操作来说，性能更佳。</p><p>表级锁与行级锁的对比：</p><p><strong>表级锁：</strong>MySQL中粒度最大的一种锁，针对非索引字段加的锁。资源消耗少，加锁快也不会出现死锁。正因为其锁的粒度大，所以发生冲突的概率最高，并发度最低。</p><p><strong>行级锁：</strong>MySQL中粒度最小的一种锁，针对索引字段加的锁，它仅针对当前操作的行记录加锁。由于其粒度小，所以其并发度高，但对应的加锁开销也最大，导致加锁慢,会出现死锁的情况。</p><h2 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="行级锁的使用有什么注意事项？"></a>行级锁的使用有什么注意事项？</h2><p>行级锁是针对索引字段加的锁，在执行update或者delete语句的过程中，如果where条件没有命中唯一索引或者索引失效，则会对表中所有行记录加锁，因此需要避免这种情况的发生。但是这并不意味着使用了索引就能避免对所有行记录加锁的情况发生，原因在于MySQL优化器可能会让这条查询语句走全表扫描。</p><h2 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="共享锁和排他锁呢？"></a>共享锁和排他锁呢？</h2><p>表级锁与行级锁均存在<strong>共享锁</strong>与<strong>排他锁</strong>。共享锁(读锁)允许多个事务同时获取，不互斥。排他锁(写锁)，不允许多个事务同时获取，互斥。共享锁仅与共享锁兼容，排他锁与任何锁都不兼容。</p><h2 id="意向锁有什么作用？"><a href="#意向锁有什么作用？" class="headerlink" title="意向锁有什么作用？"></a>意向锁有什么作用？</h2><p>在需要添加表锁的时候，需要判断当前表中是否存在行锁。这时候就需要通过意向锁来快速判断是否可以对表添加表锁。</p><p>意向锁是表级锁，共有两种：</p><p><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中某些记录添加共享锁时，需要先获取对应的意向共享锁。</p><p><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中某些记录添加排他锁时，需要先获取对应的意向排他锁。</p><p>意向锁由数据库引擎自行维护，用户无法操作。在对行记录添加共享锁或者排他锁的时候，数据库引擎会先获取对应的意向锁。需要说明的是意向锁之间是兼容的，但是与表级的共享锁、排他锁互斥。</p><h2 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="InnoDB 有哪几类行锁？"></a>InnoDB 有哪几类行锁？</h2><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><p><strong>行记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</p></li><li><p><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</p></li><li><p><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p></li></ul><p>InnoDB 的默认隔离级别可重复读是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><p>快照读（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</p></li><li><p>当前读 （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。</p></li></ul><h2 id="当前读和快照读有什么区别？"><a href="#当前读和快照读有什么区别？" class="headerlink" title="当前读和快照读有什么区别？"></a>当前读和快照读有什么区别？</h2><p>快照读（一致性非锁定读）就是单纯的 SELECT 语句。所谓快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li><p>在 RC级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</p></li><li><p>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</p></li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p><p>当前读 （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><h2 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h2><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。</p><p>解决幻读的方式主要有以下几种：</p><ul><li><p>将事务隔离级别调整为 SERIALIZABLE 。</p></li><li><p>在可重复读的事务级别下，给事务操作的这张表添加表锁。</p></li><li><p>在可重复读的事务级别下，给事务操作的这张表添加 Next-key Lock（Record Lock+Gap Lock）</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>MySQL常见面试题总结：<a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
