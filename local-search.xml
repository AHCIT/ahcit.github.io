<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>MySQL基础面试问题总结</title>
    <link href="/2023/01/14/MySQL%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/14/MySQL%E5%9F%BA%E7%A1%80%E9%9D%A2%E8%AF%95%E9%97%AE%E9%A2%98%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基础面试问题总结"><a href="#MySQL基础面试问题总结" class="headerlink" title="MySQL基础面试问题总结"></a>MySQL基础面试问题总结</h1><h2 id="MySQL存储引擎架构"><a href="#MySQL存储引擎架构" class="headerlink" title="MySQL存储引擎架构"></a>MySQL存储引擎架构</h2><ul><li><p>MySQL存储引擎采用的是插件式架构，支持多种存储引擎</p></li><li><p>可以为不同的表设置不同的引擎来适应不同的场景</p></li><li><p>存储引擎是基于表的而非数据库</p></li></ul><h2 id="MyISAM-和-InnoDB-的区别是什么"><a href="#MyISAM-和-InnoDB-的区别是什么" class="headerlink" title="MyISAM 和 InnoDB 的区别是什么"></a>MyISAM 和 InnoDB 的区别是什么</h2><h3 id="1-是否支持行级锁"><a href="#1-是否支持行级锁" class="headerlink" title="1)    是否支持行级锁"></a>1)    是否支持行级锁</h3><p>MyISAM只有表级锁(table-level locking)，而InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁。</p><h3 id="2-是否支持外键"><a href="#2-是否支持外键" class="headerlink" title="2)    是否支持外键"></a>2)    是否支持外键</h3><p>MyISAM不支持外键，InnoDB支持外键</p><h3 id="3-是否支持事务"><a href="#3-是否支持事务" class="headerlink" title="3)    是否支持事务"></a>3)    是否支持事务</h3><p>MyISAM不支持事务，InnoDB支持事务。隔离级别默认使用可重复读，可以避免幻读的情况发生。</p><h3 id="4-是否支持数据库异常崩溃后的安全恢复"><a href="#4-是否支持数据库异常崩溃后的安全恢复" class="headerlink" title="4)    是否支持数据库异常崩溃后的安全恢复"></a>4)    是否支持数据库异常崩溃后的安全恢复</h3><p>MyISAM不支持，InnoDB支持，数据库重启时依赖redo log。</p><h3 id="5-是否支持MVCC"><a href="#5-是否支持MVCC" class="headerlink" title="5)    是否支持MVCC"></a>5)    是否支持MVCC</h3><p>MVCC是指多版本并发控制。MVCC是在并发访问数据库时，通过对数据进行多版本控制，避免因写锁而导致读操作的堵塞，从而很好的优化并发堵塞问题。仅InnoDB支持。</p><h3 id="6-索引的实现不一样"><a href="#6-索引的实现不一样" class="headerlink" title="6)    索引的实现不一样"></a>6)    索引的实现不一样</h3><p>虽均使用B+Tree作为索引结构，但是两者的实现方式不太一样。</p><p>a)     InnoDB引擎中，其数据文件本身就是索引文件。</p><p>b)    MyISAM，索引文件和数据文件是分离的。</p><p>c)     InnoDB引擎中，表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><h2 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="MySQL 查询缓存"></a>MySQL 查询缓存</h2><p>查询时会先查询缓存，可以提升查询的响应速度，8.0版本移除了该功能。可以通过query_cache_type参数控制是否启用缓存。开启后使用相同的查询条件与数据会直接命中缓存。但是也存在3类无法命中缓存的情况：</p><p>a)     查询条件在字符上存在差异；</p><p>b)    查询中包含用户自定义的函数、存储函数、用户变量、临时表、系统表；</p><p>c)     缓存系统中涉及的表发生变动后，与该表相关的缓存会集体失效</p><p>缓存虽然可以提升查询速度，但是带了额外的开销，不适用于写密集的应用。即便是开启也需要将缓存空间的大小控制在几十MB的范围内。</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><p>广义上的事务是逻辑上的一组操作，要么都执行，要么都不执行。数据库事务指的是保证多个对数据库的操作在宏观上可以被当作一个整体执行，要么一起成功，要么一起失败。</p><p>事务具有四个性质：</p><p>a)     原子性：事务是最小执行单位，不允许分割。该性质保证动作要么全部完成，要么完全不起作用；</p><p>b)    一致性：执行事务前后，数据保持一致。例如转账场景下，转账人与被转账人的总额应该是不变的；</p><p>c)     隔离性：并发访问数据库时，一个用户的事务不会被其他事务所干扰，并发事务之间数据库时独立的；</p><p>d)    持久性：一旦事务被提交执行，那么其对数据库中的数据修改是持久性的，即使数据库发生故障了也不应该对其修改的数据产生任何影响。</p><p>需要说明的是以上提到的原子性、隔离性、持久性均是为了保证一致性。换句话说，原子性、隔离性、持久性是数据库的性质，而一致性则属于应用程序的性质。</p><h2 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="并发事务带来了哪些问题"></a>并发事务带来了哪些问题</h2><h3 id="1-脏读："><a href="#1-脏读：" class="headerlink" title="1)    脏读："></a>1)    脏读：</h3><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><h3 id="2-丢失修改："><a href="#2-丢失修改：" class="headerlink" title="2)    丢失修改："></a>2)    丢失修改：</h3><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><h3 id="3-不可重复读："><a href="#3-不可重复读：" class="headerlink" title="3)    不可重复读："></a>3)    不可重复读：</h3><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务修改了该数据，那么在第一个事务中会出现两次读取的数据不一致的情况，称之为不可重复读。</p><h3 id="4-幻读："><a href="#4-幻读：" class="headerlink" title="4)    幻读："></a>4)    幻读：</h3><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><h2 id="不可重复读和幻读有什么区别"><a href="#不可重复读和幻读有什么区别" class="headerlink" title="不可重复读和幻读有什么区别"></a>不可重复读和幻读有什么区别</h2><p>不可重复读的重点是内容修改或记录减少比如多次读取一条记录发现其中某些记录的值被修改；</p><p>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</p><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h2 id="SQL-标准定义了哪些事务隔离级别"><a href="#SQL-标准定义了哪些事务隔离级别" class="headerlink" title="SQL 标准定义了哪些事务隔离级别?"></a>SQL 标准定义了哪些事务隔离级别?</h2><p>SQL 标准定义了四个隔离级别：</p><p><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p><p><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="MySQL-的隔离级别是基于锁实现的吗"><a href="#MySQL-的隔离级别是基于锁实现的吗" class="headerlink" title="MySQL 的隔离级别是基于锁实现的吗"></a>MySQL 的隔离级别是基于锁实现的吗</h2><p>MySQL的隔离级别是基于锁和MVCC共同实现的。其中可串行化是通过锁实现的。剩下的读未提交、读已提交、可重复读均是基于MVCC实现。不过，可串行化之外的其他隔离级别可能也需要用到锁机制，就比如可重复读在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h2 id="MySQL-的默认隔离级别是什么？"><a href="#MySQL-的默认隔离级别是什么？" class="headerlink" title="MySQL 的默认隔离级别是什么？"></a>MySQL 的默认隔离级别是什么？</h2><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是可重复读。</p><h2 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="表级锁和行级锁了解吗？有什么区别？"></a>表级锁和行级锁了解吗？有什么区别？</h2><p>MyISAM仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性能非常差。</p><p>InnoDB不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（一行或者多行），所以其对并发写入操作来说，性能更佳。</p><p>表级锁与行级锁的对比：</p><p><strong>表级锁：</strong>MySQL中粒度最大的一种锁，针对非索引字段加的锁。资源消耗少，加锁快也不会出现死锁。正因为其锁的粒度大，所以发生冲突的概率最高，并发度最低。</p><p><strong>行级锁：</strong>MySQL中粒度最小的一种锁，针对索引字段加的锁，它仅针对当前操作的行记录加锁。由于其粒度小，所以其并发度高，但对应的加锁开销也最大，导致加锁慢,会出现死锁的情况。</p><h2 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="行级锁的使用有什么注意事项？"></a>行级锁的使用有什么注意事项？</h2><p>行级锁是针对索引字段加的锁，在执行update或者delete语句的过程中，如果where条件没有命中唯一索引或者索引失效，则会对表中所有行记录加锁，因此需要避免这种情况的发生。但是这并不意味着使用了索引就能避免对所有行记录加锁的情况发生，原因在于MySQL优化器可能会让这条查询语句走全表扫描。</p><h2 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="共享锁和排他锁呢？"></a>共享锁和排他锁呢？</h2><p>表级锁与行级锁均存在<strong>共享锁</strong>与<strong>排他锁</strong>。共享锁(读锁)允许多个事务同时获取，不互斥。排他锁(写锁)，不允许多个事务同时获取，互斥。共享锁仅与共享锁兼容，排他锁与任何锁都不兼容。</p><h2 id="意向锁有什么作用？"><a href="#意向锁有什么作用？" class="headerlink" title="意向锁有什么作用？"></a>意向锁有什么作用？</h2><p>在需要添加表锁的时候，需要判断当前表中是否存在行锁。这时候就需要通过意向锁来快速判断是否可以对表添加表锁。</p><p>意向锁是表级锁，共有两种：</p><p><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中某些记录添加共享锁时，需要先获取对应的意向共享锁。</p><p><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中某些记录添加排他锁时，需要先获取对应的意向排他锁。</p><p>意向锁由数据库引擎自行维护，用户无法操作。在对行记录添加共享锁或者排他锁的时候，数据库引擎会先获取对应的意向锁。需要说明的是意向锁之间是兼容的，但是与表级的共享锁、排他锁互斥。</p><h2 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="InnoDB 有哪几类行锁？"></a>InnoDB 有哪几类行锁？</h2><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><p><strong>行记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</p></li><li><p><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</p></li><li><p><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p></li></ul><p>InnoDB 的默认隔离级别可重复读是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><p>快照读（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</p></li><li><p>当前读 （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。</p></li></ul><h2 id="当前读和快照读有什么区别？"><a href="#当前读和快照读有什么区别？" class="headerlink" title="当前读和快照读有什么区别？"></a>当前读和快照读有什么区别？</h2><p>快照读（一致性非锁定读）就是单纯的 SELECT 语句。所谓快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li><p>在 RC级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</p></li><li><p>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</p></li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p><p>当前读 （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><h2 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h2><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。</p><p>解决幻读的方式主要有以下几种：</p><ul><li><p>将事务隔离级别调整为 SERIALIZABLE 。</p></li><li><p>在可重复读的事务级别下，给事务操作的这张表添加表锁。</p></li><li><p>在可重复读的事务级别下，给事务操作的这张表添加 Next-key Lock（Record Lock+Gap Lock）</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>MySQL常见面试题总结：<a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引</title>
    <link href="/2023/01/14/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/01/14/MySQL%E7%B4%A2%E5%BC%95%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引"><a href="#MySQL索引" class="headerlink" title="MySQL索引"></a>MySQL索引</h1><h2 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h2><ul><li>定义：一种用于快速查询和检索数据的数据结构，可以看成一种排序好的数据结构。</li><li>底层数据结构：常见的有B树、B+树和Hash、红黑树。在MySQL中，MyISAM和InnoDB都使用了B+树作为底层的数据结构。</li></ul><h2 id="索引的优缺点："><a href="#索引的优缺点：" class="headerlink" title="索引的优缺点："></a>索引的优缺点：</h2><p>一般情况下，基于索引的查询比全表扫描要快，但是在数据量不大的时候，这种速度上的优势并不明显。</p><p><strong>优点:</strong></p><ul><li>使用索引可以加快查询速度。</li><li>唯一索引可以保证行记录的唯一性 。</li></ul><p><strong>缺点：</strong></p><ul><li>创建以及维护索引需要耗费很多时间。在对数据进行增删改的过程中如果关联到了索引列，则对应的索引也要进行对应的修改，此时会影响索引的执行效率。</li><li>索引文件需要使用物理文件存储，会耗费一定的空间。</li></ul><h2 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据。在处理hash冲突问题时，通常用的是链地址法。</p><h3 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h3><p>B树又称B-树，全称为多路平衡查找树，而B+树是B树的一种变体，两者的区别在于以下三点：</p><ul><li><p>B树的所有节点既存放key也存放data。但B+树只有叶子节点存放key和data，其他内节点只存放key，<strong>因为这样一个节点就可以存储更多的key，可以使得B+树相对B树来说更矮（IO次数就是树的高度），所以与磁盘交换的IO操作次数更少。</strong></p></li><li><p>B树的叶子节点都是独立的，但B+树叶子节点有一条引用链是指向相邻的叶子节点，便于进行范围查询。</p></li><li><p>B树在检索的过程中相当于对范围内每个节点关键字做二分查找，存在未到达叶子节点就已经结束查询的情况。相对的，B+树的查询效率则更加稳定，原因在于任何查询都是从根节点开始，到叶子节点结束。</p></li></ul><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。MySQL基于InnoDB存储引擎的表中，在未显式的指定表的主键时，InnoDB 首先会检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。简而言之，它是指向主键索引的索引</strong></p><p>常见的唯一索引、普通索引、前缀索引均属于二级索引。</p><ul><li><strong>唯一索引：</strong>唯一索引的约束意义大于索引意义，它所关联的列不允许出现重复的数据，但是可以为null。建立该索引的目的大部分时候是为了保证该属性列的唯一性，而不是为了查询效率。</li><li><strong>普通索引：</strong>普通索引的唯一作用就是加速查询。它允许数据重复与null。</li><li><strong>前缀索引：</strong>仅适用于字符串类型，仅对文本的前几个字符创建索引。</li><li><strong>全文索引：</strong>针对大文本内的关键词检索场景。MyISAM与Mysql 5.6之后的版本均支持。</li></ul><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><h3 id="聚簇索引（聚集索引）"><a href="#聚簇索引（聚集索引）" class="headerlink" title="聚簇索引（聚集索引）"></a>聚簇索引（聚集索引）</h3><p><strong>聚簇索引即是指索引信息与数据信息存放在一起的索引，InnoDB中的主键索引就是典型的聚簇索引。</strong></p><p><strong>聚簇索引的优缺点：</strong></p><p><strong>优点：</strong></p><ul><li>基于聚簇索引的查询速度非常快，原因在于B+树是一颗多路平衡二叉树，而且其叶子节点也都是有序的。在定位到索引节点后，能从节点中读取到相应的数据。相较于非聚簇索引，它减少了一次IO操作。</li><li>对排序查找与范围查找优化：基于主键的聚簇索引的排序查找和范围查找速度非常快。</li><li>使用覆盖索引扫描的查询可以直接使用页结点中的主键值。</li></ul><p><strong>缺点：</strong></p><ul><li>聚簇索引最大限度地提高了I&#x2F;O密集型应用的性能，但如果数据全部都放在<strong>内存</strong>中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li><li>插入速度严重依赖于插入顺序。如果按照主键顺序插入数据，那么速度是最快的，且形成一个紧凑的索引结构，如果不是，那么在加载完成后最好使用OPTIMIZE TABLE重新组织一下表。由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，那么可能会涉及到其他位置的数据位置进行频繁调整，降低效率。<strong>因此InnoDB一定建议使用自增逻辑主键。</strong></li><li>当插入行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次“<strong>页分裂</strong>”操作，页分裂会导致表占用更多的磁盘空间，并且使索引结构变得不紧凑（原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%），形成很多磁盘碎片，可能导致全表扫描变慢。</li><li><strong>更新、删除聚簇索引列的代价同样很高</strong>，因为会强制InnoDB将每个被更新的行移动到新的位置，并涉及到其他行的位置移动，同样可能造成页分裂、磁盘碎片化、页合并等问题。</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li><li><strong>二级索引访问需要两次索引查找</strong>，而不是一次。因为二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行，两次B-Tree查找。</li></ul><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p><strong>非聚簇索引即索引结构和数据分开存放的索引，二级索引就是典型的非聚簇索引。</strong>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的主键，根据主键再回表查询数据。</p><p><strong>非聚簇索引的优缺点：</strong></p><p><strong>优点：</strong></p><p>更新索引的代价比聚簇索引小，因为非聚簇索引的叶子节点是不存放数据的。</p><p><strong>缺点：</strong></p><ul><li>依赖于有序的数据</li><li>可能会二次查询（回表）。当查到索引对应的指针或主键后，可能还需要更具指针或者主键再到数据文件或者表中查询。<strong>这里的”可能”体现在，当索引字段就是需要返回的字段的时候是不用回表的，此时又可以称之为覆盖索引。</strong></li></ul><h2 id="覆盖索引与联合索引"><a href="#覆盖索引与联合索引" class="headerlink" title="覆盖索引与联合索引"></a>覆盖索引与联合索引</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h3><p>如果一个索引包含（覆盖）了所有需要查询的字段的值，则将其称之为覆盖索引。覆盖索引的好处是可以减少一次回表操作，因为索引key已经涵盖了要查询的数据。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>使用表中的多个字段创建索引，就是联合索引，也叫组合索引或者复合索引。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>最左前缀匹配原则是指，当查询使用到联合索引时，会从左到右以此去匹配索引字段。如果查询条件中存在于联合索引中最左侧字段相匹配的字段，则会通过该字段过滤掉一部分数据，直至联合索引中的全部字段匹配完成，或者在执行过程中遇到了范围查询也会停止匹配。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推是MySQL5.6版本中提供的一项索引优化功能。</p><p><strong>使用下推索引与不使用的区别：</strong></p><ul><li><p>在不使用索引下推时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，由服务器判断数据是否符合条件。</p></li><li><p>在使用索引下推时，如果粗在某些被索引列的判断条件，MySQL服务器会将这一部分的判断条件传递给存储引擎，这时候就不是由服务器去判断这部分条件了，而是由存储引擎判断索引是否符合条件。只有当索引符合条件时，存储引擎才会将检索到的数据返回给MySQL服务器。</p></li></ul><p><strong>索引条件下推可以减少存储引擎查询基础表的次数，也可以减少MySQL服务其从存储引擎接收数据的次数。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>MySQL索引详解：<a href="https://javaguide.cn/database/mysql/mysql-index.html">https://javaguide.cn/database/mysql/mysql-index.html</a></li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
