<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>LeetCode 25. K个一组翻转链表</title>
    <link href="/2023/02/26/LeetCode-25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/02/26/LeetCode-25-K%E4%B8%AA%E4%B8%80%E7%BB%84%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-25-K个一组翻转链表"><a href="#LeetCode-25-K个一组翻转链表" class="headerlink" title="LeetCode 25.  K个一组翻转链表"></a>LeetCode 25.  <a href="https://leetcode.cn/problems/reverse-nodes-in-k-group/description/">K个一组翻转链表</a></h3><p>给你链表的头节点 <code>head</code> ，每 <code>k</code> 个节点一组进行翻转，请你返回修改后的链表。<code>k</code> 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 <code>k</code> 的整数倍，那么请将最后剩余的节点保持原有顺序。你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p><p><strong>分析：</strong>本题可以采用问题拆解的方式去解决，首先解决k个节点的链表反转问题，再将每组反转的链表串联起来。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseKGroup</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> k)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">q</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; k; i++) &#123;<br>            <span class="hljs-keyword">if</span> (q == <span class="hljs-literal">null</span>) &#123;<br>                <span class="hljs-keyword">return</span> head;<br>            &#125;<br>            q = q.next;<br>        &#125;<br>      <span class="hljs-comment">// 得到该组反转的结果，并记录头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">newHead</span> <span class="hljs-operator">=</span> reverseAB(head, q);<br>      <span class="hljs-comment">// 反转前的head在反转后变为最后一个结点，让其指向下一组的头结点</span><br>        head.next = reverseKGroup(q, k);<br>      <span class="hljs-comment">// 返回反转后的链表的头结点</span><br>        <span class="hljs-keyword">return</span> newHead;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反转单链表</span><br><span class="hljs-comment">     * a-&gt;a1-&gt;a2-&gt;a3-&gt;a4-&gt;a5-&gt;null</span><br><span class="hljs-comment">     * a&lt;-a1&lt;-a2&lt;-a3&lt;-a4&lt;-a5-&gt;null</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> head 链表头</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反转后的单链表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur, nxt;<br>        cur = head;<br>        <span class="hljs-keyword">while</span> (cur != <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-comment">// 记录当前结点的的下一个结点</span><br>            nxt = cur.next;<br>            <span class="hljs-comment">// 调转当前结点的指针方向</span><br>            cur.next = pre;<br>            <span class="hljs-comment">// 更新pre，向右移动一步，即指向cur</span><br>            pre = cur;<br>            <span class="hljs-comment">// 更新cur，另一个链表的头结点</span><br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 反转单链表[a,b),一般化</span><br><span class="hljs-comment">     * a-&gt;a1-&gt;a2-&gt;a3-&gt;a4-&gt;a5-&gt;b</span><br><span class="hljs-comment">     * a&lt;-a1&lt;-a2&lt;-a3&lt;-a4&lt;-a5-&gt;b</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> a 链表起始点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> b 链表结束点</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 反转后的链表</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseAB</span><span class="hljs-params">(ListNode a, ListNode b)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">pre</span> <span class="hljs-operator">=</span> <span class="hljs-literal">null</span>, cur = a, nxt;<br>        <span class="hljs-keyword">while</span> (cur != b) &#123;<br>            <span class="hljs-comment">// 记录右侧链表表头的下一个结点，用于更新下一轮循环的表头</span><br>            nxt = cur.next;<br>            <span class="hljs-comment">// 将右侧链表表头的后继改为pre，完成反转</span><br>            cur.next = pre;<br>            <span class="hljs-comment">// 更新左侧链表的表头pre，向右移一位，指向cur</span><br>            pre = cur;<br>            <span class="hljs-comment">// 更新右侧链表表头</span><br>            cur = nxt;<br>        &#125;<br>        <span class="hljs-comment">// 返回的是pre，左侧链表头</span><br>        <span class="hljs-keyword">return</span> pre;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 206.反转链表</title>
    <link href="/2023/02/23/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/02/23/LeetCode-206-%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-206-反转链表"><a href="#LeetCode-206-反转链表" class="headerlink" title="LeetCode 206.  反转链表"></a>LeetCode 206.  <a href="https://leetcode.cn/problems/reverse-linked-list/description/">反转链表</a></h3><p>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>分析：</strong>本题用迭代法比较简单不做赘述，主要考虑如何用递归的方法实现。需要考虑的点有3个。</p><ol><li><strong>递归函数的设计：</strong>凡是用到递归的地方，首先要做的就是明确递归函数本身在完成一件什么样的事情。我这里的递归函数需要完成的事情就是给定一个单链表返回它反转后的结果。换句话说，只要是调用了了该函数，它返回的单链表一定被反转了。</li><li><strong>base case的分析：</strong>当单链表为空或者只有一个结点时显然直接返回即可。</li><li><strong>递归内部的反转逻辑：</strong>核心语句只有一句<code>head.next.next=head</code>。这句拆成两步来解读就很好理解了，假设<code>p = head.next</code>，则<code>head.next.next=head</code>就可以拆成<code>p=head.next</code>; <code>p.next=head</code>，这里就完成了反转的操作。但是不要忘记将<code>head.next</code>清空，不然head后面还连着<code>p</code>结点。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverseList</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">return</span> reverse(head);<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">reverse</span><span class="hljs-params">(ListNode head)</span> &#123;<br>        <span class="hljs-keyword">if</span> (head == <span class="hljs-literal">null</span> || head.next == <span class="hljs-literal">null</span>) &#123;<br>            <span class="hljs-keyword">return</span> head;<br>        &#125;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">last</span> <span class="hljs-operator">=</span> reverse(head.next);<br>        head.next.next = head;<br>        head.next = <span class="hljs-literal">null</span>;<br>        <span class="hljs-keyword">return</span> last;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 19. 删除链表的倒数第 N 个结点</title>
    <link href="/2023/02/20/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/"/>
    <url>/2023/02/20/LeetCode-19-%E5%88%A0%E9%99%A4%E9%93%BE%E8%A1%A8%E7%9A%84%E5%80%92%E6%95%B0%E7%AC%AC-N-%E4%B8%AA%E7%BB%93%E7%82%B9/</url>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-19-删除链表的倒数第-N-个结点"><a href="#LeetCode-19-删除链表的倒数第-N-个结点" class="headerlink" title="LeetCode 19.  删除链表的倒数第 N 个结点"></a>LeetCode 19.  <a href="https://leetcode.cn/problems/remove-nth-node-from-end-of-list/description/">删除链表的倒数第 N 个结点</a></h3><p>给你一个链表，删除链表的倒数第 <code>n</code> 个结点，并且返回链表的头结点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">removeNthFromEnd</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> n)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        dummy.next = head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy, q = dummy; <br>        <span class="hljs-comment">// 找到第倒数n+1个结点，并让该结点的next指向next的next结点</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; n+<span class="hljs-number">1</span>; i++)&#123;<br>            q = q.next;<br>        &#125;<br>        <span class="hljs-keyword">while</span>(q != <span class="hljs-literal">null</span>)&#123;<br>            q = q.next;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-comment">// p为倒数第n+1个结点</span><br>        p.next = p.next.next;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;    <br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 23. 合并K个升序链表</title>
    <link href="/2023/02/20/LeetCode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/02/20/LeetCode-23-%E5%90%88%E5%B9%B6K%E4%B8%AA%E5%8D%87%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-23-合并K个升序链表"><a href="#LeetCode-23-合并K个升序链表" class="headerlink" title="LeetCode 23.  合并K个升序链表"></a>LeetCode 23.  <a href="https://leetcode.cn/problems/merge-k-sorted-lists/description/">合并K个升序链表</a></h3><p>给你一个链表数组，每个链表都已经按升序排列。请你将所有链表合并到一个升序链表中，返回合并后的链表。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeKLists</span><span class="hljs-params">(ListNode[] lists)</span> &#123;<br>        <span class="hljs-comment">// 边界值考虑</span><br>        <span class="hljs-keyword">if</span>(lists.length == <span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;<br>        &#125;<br>        <span class="hljs-comment">// 虚拟头结点</span><br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy;<br>        PriorityQueue&lt;ListNode&gt; pq = <span class="hljs-keyword">new</span> <span class="hljs-title class_">PriorityQueue</span>&lt;&gt;(lists.length,(a, b)-&gt;(a.val - b.val));<br>        <span class="hljs-comment">// 建堆</span><br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; lists.length; i++)&#123;<br>            <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> == lists[i])&#123;<br>                <span class="hljs-keyword">continue</span>;<br>            &#125;<br>            pq.offer(lists[i]);<br>        &#125;<br>        <span class="hljs-comment">// 更新堆</span><br>        <span class="hljs-keyword">while</span>(!pq.isEmpty())&#123;<br>            <span class="hljs-comment">// 取出堆顶元素</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">cur</span> <span class="hljs-operator">=</span> pq.poll();<br>            <span class="hljs-comment">// 添加到p.next</span><br>            p.next = cur;<br>            <span class="hljs-comment">// 更新p</span><br>            p = p.next;<br>            <span class="hljs-comment">// 调整堆</span><br>            <span class="hljs-keyword">if</span>(cur.next != <span class="hljs-literal">null</span>)&#123;<br>                cur = cur.next;<br>                pq.offer(cur);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 86. 分割链表</title>
    <link href="/2023/02/20/LeetCode-86-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/02/20/LeetCode-86-%E5%88%86%E5%89%B2%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-86-分隔链表"><a href="#LeetCode-86-分隔链表" class="headerlink" title="LeetCode 86.  分隔链表"></a>LeetCode 86.  <a href="https://leetcode.cn/problems/partition-list/description/?orderBy=hot">分隔链表</a></h3><p>给你一个链表的头节点 <code>head</code> 和一个特定值 <code>x</code> ，请你对链表进行分隔，使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前。</p><p>你应当 <strong>保留</strong> 两个分区中每个节点的初始相对位置。</p><p><strong>分析：</strong>本题的关键点有两个</p><ol><li><p>使得所有 <strong>小于</strong> <code>x</code> 的节点都出现在 <strong>大于或等于</strong> <code>x</code> 的节点之前</p><p>这句话读起来很绕口，但是本质上表达的意义就是在遍历单链表的过程把小于x的结点放到左边，把大于或等于x的结点放到右边</p></li><li><p>有了1的说明，编码实现已经是手到擒来的事情了，但在实现的过程中需要考虑将遍历到的结点置为孤结点。</p><p><strong>解释：</strong>假设以p结点作为遍历结点，当我们确定p属于左边还是右边以后，需要切断了p的后续结点，使之成为一个孤结点。如果不使p为成为一个孤节点，则相当于将以p为首的单链表加到了p1或者p2后面，这不是我们想要的。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">partition</span><span class="hljs-params">(ListNode head, <span class="hljs-type">int</span> x)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy1</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy2</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">2</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> head;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p1</span> <span class="hljs-operator">=</span> dummy1;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p2</span> <span class="hljs-operator">=</span> dummy2;<br>        <span class="hljs-keyword">while</span>(p != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span>(p.val &lt; x)&#123;<br>                p1.next = p;<br>                p1 = p1.next;<br>            &#125;<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p.val &gt;= x)&#123;<br>                p2.next = p;<br>                p2 = p2.next;<br>            &#125;<br>            <span class="hljs-comment">// 保存以p.next为首的链表</span><br>            <span class="hljs-type">ListNode</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> p.next;<br>            <span class="hljs-comment">// 切断p的后续结点，使p成为了一个孤节点</span><br>            p.next = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 更新p的位置</span><br>            p = temp;<br>        &#125;<br>        p1.next = dummy2.next;<br>        <span class="hljs-keyword">return</span> dummy1.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LeetCode 21. 合并两个有序链表</title>
    <link href="/2023/02/19/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <url>/2023/02/19/%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="LeetCode-21-合并两个有序链表"><a href="#LeetCode-21-合并两个有序链表" class="headerlink" title="LeetCode 21. 合并两个有序链表"></a>LeetCode 21. <a href="https://leetcode.cn/problems/merge-two-sorted-lists/description/">合并两个有序链表</a></h3><p>将两个升序链表合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Definition for singly-linked list.</span><br><span class="hljs-comment"> * public class ListNode &#123;</span><br><span class="hljs-comment"> *     int val;</span><br><span class="hljs-comment"> *     ListNode next;</span><br><span class="hljs-comment"> *     ListNode() &#123;&#125;</span><br><span class="hljs-comment"> *     ListNode(int val) &#123; this.val = val; &#125;</span><br><span class="hljs-comment"> *     ListNode(int val, ListNode next) &#123; this.val = val; this.next = next; &#125;</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">public</span> ListNode <span class="hljs-title function_">mergeTwoLists</span><span class="hljs-params">(ListNode list1, ListNode list2)</span> &#123;<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">dummy</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">ListNode</span>(-<span class="hljs-number">1</span>);<br>        <span class="hljs-type">ListNode</span> <span class="hljs-variable">p</span> <span class="hljs-operator">=</span> dummy, p1 = list1, p2 = list2;<br>        <span class="hljs-comment">// 循环条件 p1 != null 或  p2 != null</span><br>        <span class="hljs-keyword">while</span>(p1 != <span class="hljs-literal">null</span> ||  p2 != <span class="hljs-literal">null</span>)&#123;<br>            <span class="hljs-keyword">if</span> (p1 == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">// p1遍历结束，接上p2，跳出循环</span><br>                p.next = p2;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p2 == <span class="hljs-literal">null</span>)&#123;<br>                <span class="hljs-comment">// p2遍历结束，接上p1，跳出循环</span><br>                p.next = p1;<br>                <span class="hljs-keyword">break</span>;<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p1.val &lt;= p2.val)&#123;<br>                <span class="hljs-comment">// p1对应的值更小，接上p1</span><br>                p.next = p1;<br>                p1 = p1.next;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-comment">// p2对应的值更小，接上p1</span><br>                p.next = p2;<br>                p2 = p2.next;<br>            &#125;<br>            p = p.next;<br>        &#125;<br>        <span class="hljs-keyword">return</span> dummy.next;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>LeetCode</category>
      
    </categories>
    
    
    <tags>
      
      <tag>链表</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引页分裂详解</title>
    <link href="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/"/>
    <url>/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL数据页分裂详解"><a href="#MySQL数据页分裂详解" class="headerlink" title="MySQL数据页分裂详解"></a>MySQL数据页分裂详解</h1><p>在介绍聚簇索引时提到，当插入行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行。那么页分裂的过程到底是怎样的呢？首先需要阐明的一点是，InnoDB从磁盘中读取数据的最小单位时数据页，我们需要的数据记录就包含在数据页当中。</p><h2 id="数据页的逻辑结构"><a href="#数据页的逻辑结构" class="headerlink" title="数据页的逻辑结构"></a>数据页的逻辑结构</h2><p>关于数据页的逻辑结构可以通过下图来进行描述</p><img src="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/data_page_description.png" class="" title="数据页逻辑结构图"><p>从图中可以看到一个数据页由七个部分组成，每个部分的意义见下表。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>大小</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>File Header</td><td>38字节</td><td>所有页的通用文件头信息</td></tr><tr><td>Page Header</td><td>56字节</td><td>索引页特有的页头信息</td></tr><tr><td>Infimum(下界)+Supremum(上界)</td><td>26字节</td><td>页中虚拟的最小、最大记录，上界大于当前存在的最大主键值，下界小于当前最小主键值</td></tr><tr><td>User Records</td><td>变长</td><td>用户记录数据</td></tr><tr><td>Free Space</td><td>变长</td><td>空闲空间</td></tr><tr><td>Page Directory</td><td>变长</td><td>页目录，加速页内数据检索效率</td></tr><tr><td>File Trailer</td><td>8字节</td><td>所有页的通用文件尾信息，校验页是否完整</td></tr></tbody></table><h3 id="File-Header"><a href="#File-Header" class="headerlink" title="File Header"></a>File Header</h3><p>File Header是所有页都有的一个通用的结构，占用固定的38字节，它记录了页的一些通用的状态信息，例如：页的页号、Checksum、把页串联成双向链表的指针、页的类型等等。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>大小</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>FIL_PAGE_SPACE_OR_CHECKSUM</td><td>4字节</td><td>新版本中代表页的校验和Checksum</td></tr><tr><td>FIL_PAGE_OFFSET</td><td>4字节</td><td>页号</td></tr><tr><td>FIL_PAGE_PREV</td><td>4字节</td><td>上一个页的页号</td></tr><tr><td>FIL_PAGE_NEXT</td><td>4字节</td><td>下一个页的页号</td></tr><tr><td>FIL_PAGE_LSN</td><td>8字节</td><td>页面最后被修改时的LSN值</td></tr><tr><td>FIL_PAGE_TYPE</td><td>2字节</td><td>页的类型</td></tr><tr><td>FIL_PAGE_FILE_FLUSH_LSN</td><td>8字节</td><td>仅在系统表空间的第1个页中使用，代表文件至少被刷新到了对应的LSN值</td></tr><tr><td>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</td><td>4字节</td><td>页数据哪个表空间</td></tr></tbody></table><ul><li><strong>FIL_PAGE_SPACE_OR_CHECKSUM</strong></li></ul><p>基于当前页计算出的校验和(Checksum)，可以把它看作是哈希值，校验和不同，则两个页数据肯定不同。它的作用是InnoDB在脏页刷盘时，有可能会遇到页刷到一半断电的情况，页的头和尾部分分别记录校验和，只有当头尾的校验和一致的时候，才代表磁盘上的页是完整的，否则就是一个损坏的页。</p><ul><li><strong>FIL_PAGE_OFFSET</strong></li></ul><p>页号，页的唯一标识，全局递增的数字，InnoDB通过页号来定位唯一的一个页。4字节存储，意味着一个表空间最多可以有232个页，按照一个页16KB计算，则一个表空间最多支持64TB的数据。</p><ul><li><strong>FIL_PAGE_PREV &amp; FIL_PAGE_NEXT</strong></li></ul><p>一个页大小才16KB，一张表数据其实是由N多个页构成的，页与页之间在物理上可以是不连续的，但是逻辑上要连续，FIL_PAGE_PREV和FIL_PAGE_NEXT分别指向当前页的上一个页和下一个页的页号，通过这两个指针将索引页串联成了一个双向链表。记录与记录之间是单向的，页与页之间是双向的！</p><ul><li><strong>FIL_PAGE_LSN</strong></li></ul><p>页面最后被修改时，对应的LSN值。LSN的全称是Log Sequence Number，日志序列号。它是一个递增的数字，和事务相关，这里不作赘述。</p><ul><li><strong>FIL_PAGE_TYPE</strong></li></ul><p>当前页的类型，InnoDB为了不同的目的设计了很多不同类型的页，索引页的固定值是<code>0x45BF</code>。</p><ul><li><strong>FIL_PAGE_FILE_FLUSH_LSN</strong></li></ul><p>仅在第1个页中使用，用来判断数据库是正常关闭还是异常宕机。</p><ul><li><strong>FIL_PAGE_ARCH_LOG_NO_OR_SPACE_ID</strong></li></ul><p>仅记录当前页数据哪个表空间。</p><h3 id="Page-Header"><a href="#Page-Header" class="headerlink" title="Page Header"></a>Page Header</h3><p>Page Header是索引页特有的结构，占用固定的56字节，它记录了索引页中记录相关的状态信息。</p><table><thead><tr><th><strong>名称</strong></th><th><strong>大小</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td>PAGE_N_DlR_SLOTS</td><td>2字节</td><td>页目录中的槽数量</td></tr><tr><td>PAGE_HEAP_TOP</td><td>2字节</td><td>未使用的空间最小地址，User Records和Free Space分界点</td></tr><tr><td>PAGE_N_HEAP</td><td>2字节</td><td>本页中的记录的数量(包括虚拟记录和删除记录)</td></tr><tr><td>PAGE_FREE</td><td>2字节</td><td>第一个删除的记录地址，后续删除的记录会形成链表。</td></tr><tr><td>PAGE_GARBAGE</td><td>2字节</td><td>已删除记录占用的字节数</td></tr><tr><td>PAGE_LAST_INSERT</td><td>2字节</td><td>最后插入记录的位置</td></tr><tr><td>PAGE_DIRECTION</td><td>2字节</td><td>记录插入的方向</td></tr><tr><td>PAGE_N_DIRECTION</td><td>2字节</td><td>同一个方向连续插入的记录数量</td></tr><tr><td>PAGE_N_RECS</td><td>2字节</td><td>该页中记录的数量(不包括虚拟记录和删除记录)</td></tr><tr><td>PAGE_MAX_TRX_ID</td><td>8字节</td><td>修改当前页的最大事务ID，仅在二级索引中使用</td></tr><tr><td>PAGE_LEVEL</td><td>2字节</td><td>当前页在B+树中所处的层级</td></tr><tr><td>PAGE_INDEX_ID</td><td>8字节</td><td>索引ID，表示当前页属于哪个索引</td></tr><tr><td>PAGE_BTR_SEG_LEAF</td><td>10字节</td><td>B+树叶子段的头部信息，仅在B+树的Root页定义</td></tr><tr><td>PAGE_BTR_SEG_TOP</td><td>10字节</td><td>B+树非叶子段的头部信息，仅在B+树的Root页定义</td></tr></tbody></table><p>不用每个属性都了解，我们挑几个比较重要的看看。</p><ul><li><strong>PAGE_N_DlR_SLOTS</strong></li></ul><p>一个页内可能有上千条记录，挨个遍历的话效率太慢了。为了提高页内记录的检索效率，InnoDB将页内的记录划分为多个组，组里最大的那条记录相较于页的地址偏移量会记录到「Page Directory」部分，每个组都对应一个槽，槽的大小是固定的2字节。该属性记录的就是页内槽的数量。</p><ul><li><strong>PAGE_HEAP_TOP</strong></li></ul><p>Free Space的起始位置，它是User Records和Free Space分界点。一个全新的页一开始是没有User Records部分的，每插入一条记录，都要向Free Space申请空间，Free Space耗尽就代表页满了。</p><ul><li><strong>PAGE_FREE</strong></li></ul><p>DELETE命令删除记录时，InnoDB并不会真的将记录从磁盘中删除，而是在记录的头信息里打个标记，然后将其加入到「垃圾链表」中。PAGE_FREE指向的就是垃圾链表的表头记录。后面删除的记录，也会自动加入到链表里。</p><ul><li><strong>PAGE_DIRECTION &amp; PAGE_N_DIRECTION</strong></li></ul><p>PAGE_DIRECTION表示最后一条记录插入的方向，比上一条记录值大则记为右边，反之则是左边。PAGE_N_DIRECTION表示同一方向连续插入的记录数，方向变了该值就会重置。</p><ul><li><strong>PAGE_LEVEL</strong></li></ul><p>InnoDB组织数据的形式就是B+树，树中的节点就是索引页，PAGE_LEVEL代表当前页在B+树中所处的层级。InnoDB规定，叶子节点层级为0，然后向上递增。</p><h3 id="User-Records"><a href="#User-Records" class="headerlink" title="User Records"></a>User Records</h3><blockquote><p>Infimum和Supremum也属于记录，只是为了与用户记录区分开才划分成了两部分，我们先看User Records。</p></blockquote><p>用户记录存放在User Records部分，一个全新的页一开始全是Free Space，是没有User Records部分的。每插入一条记录都需要到Free Space申请一块空间，并将其划分到User Records用来存放用户记录。当Free Space耗尽也就代表当前页已经用完了，再有新记录需要插入，就需要申请一个新的页了。</p><img src="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/index_pages.png" class="" title="索引页列表"><p>还记得MySQL的行格式吗？它决定了记录在磁盘里的存储格式。以COMPACT为例，存储格式如下图：</p><img src="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/record_store_struct.png" class="" title="行记录存储结构"><p>记录头信息里的字段比较关键，以防大家忘记，我这里再贴一下：</p><table><thead><tr><th><strong>名称</strong></th><th><strong>大小(Bit)</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>预留位1</td><td>1</td><td>没有使用</td></tr><tr><td>预留位2</td><td>1</td><td>没有使用</td></tr><tr><td>deleted_flag</td><td>1</td><td>记录删除标记</td></tr><tr><td>min_rec_flag</td><td>1</td><td>B+树非叶子节点的最小目录项标记</td></tr><tr><td>n_owned</td><td>4</td><td>同一页内同一组里最大的记录会记录组里的记录数量，其余记录该值为0</td></tr><tr><td>heap_no</td><td>13</td><td>当前记录在页面堆里的相对位置</td></tr><tr><td>record_type</td><td>3</td><td>记录类型。0:普通记录,1:B+树非叶子节点目录项记录,2:Infimum记录,3:Supremum记录.</td></tr><tr><td>next_record</td><td>16</td><td>下一条记录的相对位置</td></tr></tbody></table><p>记录头信息的最后2字节用来连接下一条记录，将页内所有记录串联成一个单向链表。所以我们隐藏变长字段长度列表和NULL值列表，记录的格式应该是这样的：</p><img src="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/record_list.png" class="" title="行记录列表"><p><strong>记录是怎么排序的？</strong> 我们已经知道，页内的记录会自动串联成一个单向链表。那这个链表的编排顺序是什么呢？是按照记录的插入时间排序的吗？其实不是的，如果表有主键，会根据主键排序；没主键有唯一非空索引，会根据该索引排序；两者都没有，InnoDB会自动生成一个<code>row_id</code>列并根据该列进行排序。</p><h3 id="Infimum-amp-Supremum"><a href="#Infimum-amp-Supremum" class="headerlink" title="Infimum &amp; Supremum"></a>Infimum &amp; Supremum</h3><p>Infimum和Supremum是索引页内的两条虚拟记录，InnoDB规定所有索引页都会有这两条记录，而且所有的用户记录都比Infimum大，都比Supremum小。 记录头信息里的heap_no代表记录在堆里的相对位置，该值越小代表记录越靠前。细心的同学会发现，上图中的用户记录heap_no值是从2开始的，那0和1呢？不说你也肯定猜到了，就是被Infimum和Supremum占用了。Infimum和Supremum的heap_no值分别是0和1，它俩在所有用户记录的最前面。</p><p>Infimum和Supremum结构非常的简单，和用户记录一样也有头信息，真实数据部分是固定的字符串，如下图所示：</p><img src="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/infimum_supermum.png" class="" title="上下界位置"><p>我们把这两条虚拟记录也加入到记录里面，完整的结构就是下面这样的：</p><img src="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/compact_infimum_supermum.png" class="" title="带上下界行记录结构"><p>Supremum记录的next_record属性为0，代表它已经没有下一条记录了。</p><h3 id="Page-Directory"><a href="#Page-Directory" class="headerlink" title="Page Directory"></a>Page Directory</h3><p>Page Directory也叫作「页目录」，它的目的是提高页内记录的检索效率。相较于一张表几千万的记录来说，一个页内几百上千条记录已经是很少很少了。可即便如此，它也有几百上千条啊，如果页内检索记录只能挨个遍历的话，那也太低效了。别忘了，页内的记录是根据索引值排好序的，我们可以巧用「二分法」来快速查找。</p><p>具体做法是：将页内所有非删除的记录划分为N个组，每个组里最后一条记录(即主键最大的记录)称作“大哥”，其余记录是“小弟”，“大哥”的<code>n_owned</code>属性记录了组内的记录数量。将“大哥”在页内的地址偏移量提取出来，按顺序依次从File Trailer部分往前写，每个地址偏移量占用2字节，称作一个「槽」，Page Directory就是由这些槽构成的。 InnoDB对于分组内的记录数量有一些规定：</p><ul><li>Infimum记录所在分组，只能有一条记录。</li><li>Supremum记录所在分组，允许有1~8条记录。</li><li>其余分组，允许有4~8条记录。</li></ul><p>由此可见，一个组里最多有8条记录，只要通过二分法快速定位到组，InnoDB也只需要遍历这8条记录，相较于遍历页内所有记录，效率要高的多。</p><img src="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/page_directory.png" class="" title="页目录内的记录定位"><h3 id="File-Trailer"><a href="#File-Trailer" class="headerlink" title="File Trailer"></a>File Trailer</h3><p>File Trailer是所有页都有的通用结构，占用固定的8字节，它的主要作用就是为了校验页的完整性。磁盘的速度实在是太慢了，InnoDB不会每次写点数据都直接刷新到磁盘上，那样MySQL会慢死。而是将页作为刷盘的基本单位，数据修改时，先改内存里的页，稍后再将整个页的数据一次性刷新到磁盘里。但是这会带来一个问题，一个页16KB，刷到第10KB的时候磁盘断电了怎么办？重启后InnoDB如何判断磁盘里的页数据是完整的？</p><p>InnoDB是这么处理的，刷盘前根据页数据计算出一个Checksum，在页头和页尾都写一份。页刷盘的时候，先刷页头再刷页尾，当头尾两个Checksum值一致的时候，代表磁盘里的页是完整的，否则就表示页头刷了页尾没刷，那肯定是刷到一半出错了。</p><table><thead><tr><th><strong>大小</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td>4字节</td><td>页的校验和Checksum</td></tr><tr><td>4字节</td><td>页最后被修改时对应的LSN的后4个字节，正常情况下应该与File Header里的FIL_PAGE_LSN的后4个字节相同。</td></tr></tbody></table><h2 id="分裂过程"><a href="#分裂过程" class="headerlink" title="分裂过程"></a>分裂过程</h2><p>假定目前每页可以存储m(偶数)条记录，现内存中存在以下数据页，每页均已填充满，并在此时插入记录m，如下图所示：</p><img src="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/full_pages.png" class="" title="数据页分裂前"><p>由于Page0中记录已满，在插入记录m时必然会导致页分裂，页分裂的过程可以概况为以下几个步骤：</p><ol><li>创建一个新页。</li><li>确定原始页可以在哪里拆分（在记录级别）</li><li>移动记录</li><li>重新定义页之间关系</li></ol><p>重新定义后的页关系如下图所示：</p><img src="/2023/01/18/MySQL%E6%95%B0%E6%8D%AE%E9%A1%B5%E5%88%86%E8%A3%82%E8%AF%A6%E8%A7%A3/full_pages_split.png" class="" title="数据页分裂后"><p>可以看到的是Page0保留了50%的数据记录，这个值是由<code>MERGE_THRESHOLD</code>参数控制的，默认为50%（可以使用<code>CREATE TABLE</code>语句的<code>table_option COMMENT</code>子句为表设置MERGE_THRESHOLD值）。因此在执行页分裂时，可以看到这里分裂后的页仍保留了一半的数据记录，并且数据页之间的前后关系也发生了对应的改变。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>MySQL索引页结构：<a href="https://juejin.cn/post/7068917155604987941">https://juejin.cn/post/7068917155604987941</a></li><li>Innodb页合并和页分裂：<a href="https://cloud.tencent.com/developer/article/1656122">https://cloud.tencent.com/developer/article/1656122</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL索引总结</title>
    <link href="/2023/01/15/MySQL%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/"/>
    <url>/2023/01/15/MySQL%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL索引总结"><a href="#MySQL索引总结" class="headerlink" title="MySQL索引总结"></a>MySQL索引总结</h1><h2 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h2><ul><li>定义：一种用于快速查询和检索数据的数据结构，可以看成一种排序好的数据结构。</li><li>底层数据结构：常见的有B树、B+树和Hash、红黑树。在MySQL中，MyISAM和InnoDB都使用了B+树作为底层的数据结构。</li></ul><h2 id="索引的优缺点："><a href="#索引的优缺点：" class="headerlink" title="索引的优缺点："></a>索引的优缺点：</h2><p>一般情况下，基于索引的查询比全表扫描要快，但是在数据量不大的时候，这种速度上的优势并不明显。</p><p><strong>优点:</strong></p><ul><li>使用索引可以加快查询速度。</li><li>唯一索引可以保证行记录的唯一性 。</li></ul><p><strong>缺点：</strong></p><ul><li>创建以及维护索引需要耗费很多时间。在对数据进行增删改的过程中如果关联到了索引列，则对应的索引也要进行对应的修改，此时会影响索引的执行效率。</li><li>索引文件需要使用物理文件存储，会耗费一定的空间。</li></ul><h2 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h2><h3 id="Hash表"><a href="#Hash表" class="headerlink" title="Hash表"></a>Hash表</h3><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据。在处理hash冲突问题时，通常用的是链地址法。</p><h3 id="B树与B-树"><a href="#B树与B-树" class="headerlink" title="B树与B+树"></a>B树与B+树</h3><p>B树又称B-树，全称为多路平衡查找树，而B+树是B树的一种变体，两者的区别在于以下三点：</p><ul><li><p>B树的所有节点既存放key也存放data。但B+树只有叶子节点存放key和data，其他内节点只存放key，<strong>因为这样一个节点就可以存储更多的key，可以使得B+树相对B树来说更矮（IO次数就是树的高度），所以与磁盘交换的IO操作次数更少。</strong></p></li><li><p>B树的叶子节点都是独立的，但B+树叶子节点有一条引用链是指向相邻的叶子节点，便于进行范围查询。</p></li><li><p>B树在检索的过程中相当于对范围内每个节点关键字做二分查找，存在未到达叶子节点就已经结束查询的情况。相对的，B+树的查询效率则更加稳定，原因在于任何查询都是从根节点开始，到叶子节点结束。</p></li></ul><h2 id="索引类型"><a href="#索引类型" class="headerlink" title="索引类型"></a>索引类型</h2><h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。MySQL基于InnoDB存储引擎的表中，在未显式的指定表的主键时，InnoDB 首先会检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。简而言之，它是指向主键索引的索引</strong></p><p>常见的唯一索引、普通索引、前缀索引均属于二级索引。</p><ul><li><strong>唯一索引：</strong>唯一索引的约束意义大于索引意义，它所关联的列不允许出现重复的数据，但是可以为null。建立该索引的目的大部分时候是为了保证该属性列的唯一性，而不是为了查询效率。</li><li><strong>普通索引：</strong>普通索引的唯一作用就是加速查询。它允许数据重复与null。</li><li><strong>前缀索引：</strong>仅适用于字符串类型，仅对文本的前几个字符创建索引。</li><li><strong>全文索引：</strong>针对大文本内的关键词检索场景。MyISAM与Mysql 5.6之后的版本均支持。</li></ul><h2 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h2><h3 id="聚簇索引（聚集索引）"><a href="#聚簇索引（聚集索引）" class="headerlink" title="聚簇索引（聚集索引）"></a>聚簇索引（聚集索引）</h3><p><strong>聚簇索引即是指索引信息与数据信息存放在一起的索引，InnoDB中的主键索引就是典型的聚簇索引。</strong></p><p><strong>聚簇索引的优缺点：</strong></p><p><strong>优点：</strong></p><ul><li>基于聚簇索引的查询速度非常快，原因在于B+树是一颗多路平衡二叉树，而且其叶子节点也都是有序的。在定位到索引节点后，能从节点中读取到相应的数据。相较于非聚簇索引，它减少了一次IO操作。</li><li>对排序查找与范围查找优化：基于主键的聚簇索引的排序查找和范围查找速度非常快。</li><li>使用覆盖索引扫描的查询可以直接使用页结点中的主键值。</li></ul><p><strong>缺点：</strong></p><ul><li>聚簇索引最大限度地提高了I&#x2F;O密集型应用的性能，但如果数据全部都放在<strong>内存</strong>中，则访问的顺序就没那么重要了，聚簇索引也就没什么优势了。</li><li>插入速度严重依赖于插入顺序。如果按照主键顺序插入数据，那么速度是最快的，且形成一个紧凑的索引结构，如果不是，那么在加载完成后最好使用OPTIMIZE TABLE重新组织一下表。由于每次插入主键的值近似于随机，因此每次新纪录都要被插到现有索引页得中间某个位置，那么可能会涉及到其他位置的数据位置进行频繁调整，降低效率。<strong>因此InnoDB一定建议使用自增逻辑主键。</strong></li><li>当插入行的主键值要求必须将这一行插入到某个已满的页中时，存储引擎会将该页分裂成两个页面来容纳该行，这就是一次“<strong>页分裂</strong>”操作，页分裂会导致表占用更多的磁盘空间，并且使索引结构变得不紧凑（原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约50%），形成很多磁盘碎片，可能导致全表扫描变慢。</li><li><strong>更新、删除聚簇索引列的代价同样很高</strong>，因为会强制InnoDB将每个被更新的行移动到新的位置，并涉及到其他行的位置移动，同样可能造成页分裂、磁盘碎片化、页合并等问题。</li><li>聚簇索引可能导致全表扫描变慢，尤其是行比较稀疏，或者由于页分裂导致数据存储不连续的时候。</li><li><strong>二级索引访问需要两次索引查找</strong>，而不是一次。因为二级索引叶子节点保存的不是指向行的物理位置的指针，而是行的主键值。二级索引查找行，存储引擎需要找到二级索引的叶子节点获得对应的主键值，然后根据这个值去聚簇索引中查找到对应的行，两次B-Tree查找。</li></ul><h3 id="非聚簇索引"><a href="#非聚簇索引" class="headerlink" title="非聚簇索引"></a>非聚簇索引</h3><p><strong>非聚簇索引即索引结构和数据分开存放的索引，二级索引就是典型的非聚簇索引。</strong>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的主键，根据主键再回表查询数据。</p><p><strong>非聚簇索引的优缺点：</strong></p><p><strong>优点：</strong></p><p>更新索引的代价比聚簇索引小，因为非聚簇索引的叶子节点是不存放数据的。</p><p><strong>缺点：</strong></p><ul><li>依赖于有序的数据</li><li>可能会二次查询（回表）。当查到索引对应的指针或主键后，可能还需要根据指针或者主键再到数据文件或者表中查询。<strong>这里的”可能”体现在，当索引字段就是需要返回的字段的时候是不用回表的，此时又可以称之为覆盖索引。</strong></li></ul><h2 id="覆盖索引与联合索引"><a href="#覆盖索引与联合索引" class="headerlink" title="覆盖索引与联合索引"></a>覆盖索引与联合索引</h2><h3 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a><strong>覆盖索引</strong></h3><p>如果一个索引包含（覆盖）了所有需要查询的字段的值，则将其称之为覆盖索引。覆盖索引的好处是可以减少一次回表操作，因为索引key已经涵盖了要查询的数据。</p><h3 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h3><p>使用表中的多个字段创建索引，就是联合索引，也叫组合索引或者复合索引。</p><h3 id="最左匹配原则"><a href="#最左匹配原则" class="headerlink" title="最左匹配原则"></a>最左匹配原则</h3><p>最左前缀匹配原则是指，当查询使用到联合索引时，会从左到右以此去匹配索引字段。如果查询条件中存在于联合索引中最左侧字段相匹配的字段，则会通过该字段过滤掉一部分数据，直至联合索引中的全部字段匹配完成，或者在执行过程中遇到了范围查询也会停止匹配。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p>索引下推是MySQL5.6版本中提供的一项索引优化功能。</p><p><strong>使用下推索引与不使用的区别：</strong></p><ul><li><p>在不使用索引下推时，存储引擎通过索引检索到数据，然后返回给MySQL服务器，由服务器判断数据是否符合条件。</p></li><li><p>在使用索引下推时，如果粗在某些被索引列的判断条件，MySQL服务器会将这一部分的判断条件传递给存储引擎，这时候就不是由服务器去判断这部分条件了，而是由存储引擎判断索引是否符合条件。只有当索引符合条件时，存储引擎才会将检索到的数据返回给MySQL服务器。</p></li></ul><p><strong>索引条件下推可以减少存储引擎查询基础表的次数，也可以减少MySQL服务其从存储引擎接收数据的次数。</strong></p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>MySQL索引详解：<a href="https://javaguide.cn/database/mysql/mysql-index.html">https://javaguide.cn/database/mysql/mysql-index.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>MySQL基础总结</title>
    <link href="/2023/01/14/MySQL%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/"/>
    <url>/2023/01/14/MySQL%E5%9F%BA%E7%A1%80%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="MySQL基础总结"><a href="#MySQL基础总结" class="headerlink" title="MySQL基础总结"></a>MySQL基础总结</h1><h2 id="MySQL存储引擎架构"><a href="#MySQL存储引擎架构" class="headerlink" title="MySQL存储引擎架构"></a>MySQL存储引擎架构</h2><ul><li><p>MySQL存储引擎采用的是插件式架构，支持多种存储引擎</p></li><li><p>可以为不同的表设置不同的引擎来适应不同的场景</p></li><li><p>存储引擎是基于表的而非数据库</p></li></ul><h2 id="MyISAM-和-InnoDB-的区别是什么"><a href="#MyISAM-和-InnoDB-的区别是什么" class="headerlink" title="MyISAM 和 InnoDB 的区别是什么"></a>MyISAM 和 InnoDB 的区别是什么</h2><h3 id="1-是否支持行级锁"><a href="#1-是否支持行级锁" class="headerlink" title="1)    是否支持行级锁"></a>1)    是否支持行级锁</h3><p>MyISAM只有表级锁(table-level locking)，而InnoDB支持行级锁(row-level locking)和表级锁，默认为行级锁。</p><h3 id="2-是否支持外键"><a href="#2-是否支持外键" class="headerlink" title="2)    是否支持外键"></a>2)    是否支持外键</h3><p>MyISAM不支持外键，InnoDB支持外键</p><h3 id="3-是否支持事务"><a href="#3-是否支持事务" class="headerlink" title="3)    是否支持事务"></a>3)    是否支持事务</h3><p>MyISAM不支持事务，InnoDB支持事务。隔离级别默认使用可重复读，可以避免幻读的情况发生。</p><h3 id="4-是否支持数据库异常崩溃后的安全恢复"><a href="#4-是否支持数据库异常崩溃后的安全恢复" class="headerlink" title="4)    是否支持数据库异常崩溃后的安全恢复"></a>4)    是否支持数据库异常崩溃后的安全恢复</h3><p>MyISAM不支持，InnoDB支持，数据库重启时依赖redo log。</p><h3 id="5-是否支持MVCC"><a href="#5-是否支持MVCC" class="headerlink" title="5)    是否支持MVCC"></a>5)    是否支持MVCC</h3><p>MVCC是指多版本并发控制。MVCC是在并发访问数据库时，通过对数据进行多版本控制，避免因写锁而导致读操作的堵塞，从而很好的优化并发堵塞问题。仅InnoDB支持。</p><h3 id="6-索引的实现不一样"><a href="#6-索引的实现不一样" class="headerlink" title="6)    索引的实现不一样"></a>6)    索引的实现不一样</h3><p>虽均使用B+Tree作为索引结构，但是两者的实现方式不太一样。</p><p>a)     InnoDB引擎中，其数据文件本身就是索引文件。</p><p>b)    MyISAM，索引文件和数据文件是分离的。</p><p>c)     InnoDB引擎中，表数据文件本身就是按B+Tree组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><h2 id="MySQL-查询缓存"><a href="#MySQL-查询缓存" class="headerlink" title="MySQL 查询缓存"></a>MySQL 查询缓存</h2><p>查询时会先查询缓存，可以提升查询的响应速度，8.0版本移除了该功能。可以通过query_cache_type参数控制是否启用缓存。开启后使用相同的查询条件与数据会直接命中缓存。但是也存在3类无法命中缓存的情况：</p><p>a)     查询条件在字符上存在差异；</p><p>b)    查询中包含用户自定义的函数、存储函数、用户变量、临时表、系统表；</p><p>c)     缓存系统中涉及的表发生变动后，与该表相关的缓存会集体失效</p><p>缓存虽然可以提升查询速度，但是带了额外的开销，不适用于写密集的应用。即便是开启也需要将缓存空间的大小控制在几十MB的范围内。</p><h2 id="MySQL-事务"><a href="#MySQL-事务" class="headerlink" title="MySQL 事务"></a>MySQL 事务</h2><p>广义上的事务是逻辑上的一组操作，要么都执行，要么都不执行。数据库事务指的是保证多个对数据库的操作在宏观上可以被当作一个整体执行，要么一起成功，要么一起失败。</p><p>事务具有四个性质：</p><p>a)     原子性：事务是最小执行单位，不允许分割。该性质保证动作要么全部完成，要么完全不起作用；</p><p>b)    一致性：执行事务前后，数据保持一致。例如转账场景下，转账人与被转账人的总额应该是不变的；</p><p>c)     隔离性：并发访问数据库时，一个用户的事务不会被其他事务所干扰，并发事务之间数据库时独立的；</p><p>d)    持久性：一旦事务被提交执行，那么其对数据库中的数据修改是持久性的，即使数据库发生故障了也不应该对其修改的数据产生任何影响。</p><p>需要说明的是以上提到的原子性、隔离性、持久性均是为了保证一致性。换句话说，原子性、隔离性、持久性是数据库的性质，而一致性则属于应用程序的性质。</p><h2 id="并发事务带来了哪些问题"><a href="#并发事务带来了哪些问题" class="headerlink" title="并发事务带来了哪些问题"></a>并发事务带来了哪些问题</h2><h3 id="1-脏读："><a href="#1-脏读：" class="headerlink" title="1)    脏读："></a>1)    脏读：</h3><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><h3 id="2-丢失修改："><a href="#2-丢失修改：" class="headerlink" title="2)    丢失修改："></a>2)    丢失修改：</h3><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><h3 id="3-不可重复读："><a href="#3-不可重复读：" class="headerlink" title="3)    不可重复读："></a>3)    不可重复读：</h3><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务修改了该数据，那么在第一个事务中会出现两次读取的数据不一致的情况，称之为不可重复读。</p><h3 id="4-幻读："><a href="#4-幻读：" class="headerlink" title="4)    幻读："></a>4)    幻读：</h3><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><h2 id="不可重复读和幻读有什么区别"><a href="#不可重复读和幻读有什么区别" class="headerlink" title="不可重复读和幻读有什么区别"></a>不可重复读和幻读有什么区别</h2><p>不可重复读的重点是内容修改或记录减少比如多次读取一条记录发现其中某些记录的值被修改；</p><p>幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</p><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 delete 和 update 操作的时候，可以直接对记录加锁，保证事务安全。而执行 insert 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 insert 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h2 id="SQL-标准定义了哪些事务隔离级别"><a href="#SQL-标准定义了哪些事务隔离级别" class="headerlink" title="SQL 标准定义了哪些事务隔离级别?"></a>SQL 标准定义了哪些事务隔离级别?</h2><p>SQL 标准定义了四个隔离级别：</p><p><strong>READ-UNCOMMITTED(读取未提交)</strong> ：最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</p><p><strong>READ-COMMITTED(读取已提交)</strong> ：允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</p><p><strong>REPEATABLE-READ(可重复读)</strong> ：对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</p><p><strong>SERIALIZABLE(可串行化)</strong> ：最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。</p><table><thead><tr><th>隔离级别</th><th>脏读</th><th>不可重复读</th><th>幻读</th></tr></thead><tbody><tr><td>读未提交</td><td>√</td><td>√</td><td>√</td></tr><tr><td>读已提交</td><td>×</td><td>√</td><td>√</td></tr><tr><td>可重复读</td><td>×</td><td>×</td><td>√</td></tr><tr><td>可串行化</td><td>×</td><td>×</td><td>×</td></tr></tbody></table><h2 id="MySQL-的隔离级别是基于锁实现的吗"><a href="#MySQL-的隔离级别是基于锁实现的吗" class="headerlink" title="MySQL 的隔离级别是基于锁实现的吗"></a>MySQL 的隔离级别是基于锁实现的吗</h2><p>MySQL的隔离级别是基于锁和MVCC共同实现的。其中可串行化是通过锁实现的。剩下的读未提交、读已提交、可重复读均是基于MVCC实现。不过，可串行化之外的其他隔离级别可能也需要用到锁机制，就比如可重复读在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h2 id="MySQL-的默认隔离级别是什么？"><a href="#MySQL-的默认隔离级别是什么？" class="headerlink" title="MySQL 的默认隔离级别是什么？"></a>MySQL 的默认隔离级别是什么？</h2><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是可重复读。</p><h2 id="表级锁和行级锁了解吗？有什么区别？"><a href="#表级锁和行级锁了解吗？有什么区别？" class="headerlink" title="表级锁和行级锁了解吗？有什么区别？"></a>表级锁和行级锁了解吗？有什么区别？</h2><p>MyISAM仅仅支持表级锁，一锁就锁整张表，这在并发写的情况下性能非常差。</p><p>InnoDB不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（一行或者多行），所以其对并发写入操作来说，性能更佳。</p><p>表级锁与行级锁的对比：</p><p><strong>表级锁：</strong>MySQL中粒度最大的一种锁，针对非索引字段加的锁。资源消耗少，加锁快也不会出现死锁。正因为其锁的粒度大，所以发生冲突的概率最高，并发度最低。</p><p><strong>行级锁：</strong>MySQL中粒度最小的一种锁，针对索引字段加的锁，它仅针对当前操作的行记录加锁。由于其粒度小，所以其并发度高，但对应的加锁开销也最大，导致加锁慢,会出现死锁的情况。</p><h2 id="行级锁的使用有什么注意事项？"><a href="#行级锁的使用有什么注意事项？" class="headerlink" title="行级锁的使用有什么注意事项？"></a>行级锁的使用有什么注意事项？</h2><p>行级锁是针对索引字段加的锁，在执行update或者delete语句的过程中，如果where条件没有命中唯一索引或者索引失效，则会对表中所有行记录加锁，因此需要避免这种情况的发生。但是这并不意味着使用了索引就能避免对所有行记录加锁的情况发生，原因在于MySQL优化器可能会让这条查询语句走全表扫描。</p><h2 id="共享锁和排他锁呢？"><a href="#共享锁和排他锁呢？" class="headerlink" title="共享锁和排他锁呢？"></a>共享锁和排他锁呢？</h2><p>表级锁与行级锁均存在<strong>共享锁</strong>与<strong>排他锁</strong>。共享锁(读锁)允许多个事务同时获取，不互斥。排他锁(写锁)，不允许多个事务同时获取，互斥。共享锁仅与共享锁兼容，排他锁与任何锁都不兼容。</p><h2 id="意向锁有什么作用？"><a href="#意向锁有什么作用？" class="headerlink" title="意向锁有什么作用？"></a>意向锁有什么作用？</h2><p>在需要添加表锁的时候，需要判断当前表中是否存在行锁。这时候就需要通过意向锁来快速判断是否可以对表添加表锁。</p><p>意向锁是表级锁，共有两种：</p><p><strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中某些记录添加共享锁时，需要先获取对应的意向共享锁。</p><p><strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中某些记录添加排他锁时，需要先获取对应的意向排他锁。</p><p>意向锁由数据库引擎自行维护，用户无法操作。在对行记录添加共享锁或者排他锁的时候，数据库引擎会先获取对应的意向锁。需要说明的是意向锁之间是兼容的，但是与表级的共享锁、排他锁互斥。</p><h2 id="InnoDB-有哪几类行锁？"><a href="#InnoDB-有哪几类行锁？" class="headerlink" title="InnoDB 有哪几类行锁？"></a>InnoDB 有哪几类行锁？</h2><p>MySQL InnoDB 支持三种行锁定方式：</p><ul><li><p><strong>行记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</p></li><li><p><strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</p></li><li><p><strong>临键锁（Next-key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</p></li></ul><p>InnoDB 的默认隔离级别可重复读是可以解决幻读问题发生的，主要有下面两种情况：</p><ul><li><p>快照读（一致性非锁定读） ：由 MVCC 机制来保证不出现幻读。</p></li><li><p>当前读 （一致性锁定读）： 使用 Next-Key Lock 进行加锁来保证不出现幻读。</p></li></ul><h2 id="当前读和快照读有什么区别？"><a href="#当前读和快照读有什么区别？" class="headerlink" title="当前读和快照读有什么区别？"></a>当前读和快照读有什么区别？</h2><p>快照读（一致性非锁定读）就是单纯的 SELECT 语句。所谓快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li><p>在 RC级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</p></li><li><p>在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</p></li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p><p>当前读 （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><h2 id="如何解决幻读"><a href="#如何解决幻读" class="headerlink" title="如何解决幻读"></a>如何解决幻读</h2><p>解决幻读的方式有很多，但是它们的核心思想就是一个事务在操作某张表数据的时候，另外一个事务不允许新增或者删除这张表中的数据了。</p><p>解决幻读的方式主要有以下几种：</p><ul><li><p>将事务隔离级别调整为 SERIALIZABLE 。</p></li><li><p>在可重复读的事务级别下，给事务操作的这张表添加表锁。</p></li><li><p>在可重复读的事务级别下，给事务操作的这张表添加 Next-key Lock（Record Lock+Gap Lock）</p></li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li>MySQL常见面试题总结：<a href="https://javaguide.cn/database/mysql/mysql-questions-01.html">https://javaguide.cn/database/mysql/mysql-questions-01.html</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>数据库</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mysql</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
